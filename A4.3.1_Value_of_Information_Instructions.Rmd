---
title: "Value of Informaton"
subtitle: Advanced Course Module 4
author: "Jack Williams & Nichola Naylor"
date: "18 April 2021"
output:
  pdf_document: default
  html_document: default
header-includes:
- \usepackage{titling}
- \pretitle{\begin{center}\LARGE\includegraphics[width=12cm]{logo.png}\\[\bigskipamount]}
- \posttitle{\end{center}}
urlcolor: blue
linkcolor: red
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r source, include=FALSE}
source("A4.3.3b_Value_of_Information_Part 2_Solution.R")
```

## Overview

The purpose of this exercise is to show how the model you have already developed can be adapted to calculate the expected value of perfect information (EVPI).  As a first step, the overall EVPI for the model is calculated in order to summarise the overall importance of uncertainty for decision-making.  Secondly, the partial EVPI for individual parameters (or groups of parameters) can be calculated in order to examine the individual contribution of different parameter (combinations) to the overall uncertainty.

The step-by-step guide below will take you through the following stages for calculating expected value of information for the overall decision problem and for the parameters of the decision model. There are 2 parts to this exercise:

**Part 1**: The following two scripts relate to this part of this exercise:
* "A4.3.2a_Value_of_Information_Part 1_Template.R"
* "A4.3.3a_Value_of_Information_Part 1_Solutions.R" 

The exercise will involve completing the following tasks:

1. Calculating per patient EVPI from simulation output
2. Calculating the effective population and population EVPI
3. Plotting EVPI as a function of the willingness to pay threshold

**Part 2**: We will be using three different scripts here 

* "A4.3.2b_Value_of_Information_Part 2_Template.R" 
* "A4.3.3b_Value_of_Information_Part 2_Solutions.R" 
* "A4.3.3b_VoI_Model_Script" 

The last template and solutions scripts will run the main model code from another script ('A4.3.3b_VoI_Model_Script') so as to avoid the code becoming too long. 

In this part of the exercise you will:

1. Look at the adaptations to the model, to see how the model function has been developed to allow for parameters to provided as arguments in the function. 
2. Working through an EVPPI manually, to ensure that you understand the process involved in each step
3. Looking through the EVPPI analyses coded for each parameter (or group of parameters), and ensuring you understand how the appropraite parameters are being selected.
4. Plotting EVPPI results across a range of willingness to pay thresholds.

Across the whole exercise we will be using the data inputs and packages discussed in previous exercises. No new data and/or packages will be used. 

\newpage 

## PART 1: Step-by-step guide

(1) **Calculating per patient EVPI from simulation output**

In the "A4.3.2a..." template file you will see that we've begun the exercise by sourcing in the model we created in Exercise 3a and storing the simulation results as we did in exercise 3a for intended group of interest (in this case females aged 60).

Recall that, under a decision theoretic approach, it is the expected outcome that should guide the decision.  That is, we will use the new prosthesis if it has an expected net benefit that is greater than that of the standard prosthesis.  However, due to uncertainty, sometimes we will make the wrong decision and the losses associated with the wrong decision are the net-benefits forgone. 

So we first need to estimate the EVPI for individual patients. 

(i) First, define a WTP threshold of your choice, to assess the EVPI (we show an example using £100,000 per QALY gained).

(ii) Estimate the NMB for SP0 and NP1 for each run using columns from the `simulation.results` data.frame, and your defined WTP. Once you have estimated the NMB for each model simulation, ensure that you have these in a data.frame (one column for each treatment).

(iii) Using the `apply()` function, estimate the the mean NMB for both treatments, across all simulations. This is the average NMB under current information. We can save this as `av.current`.  

(iv) Next, to consider the decision making under perfect information, estimate the maximum NMB for each treatment, acrosss each model simulation (i.e. the NMB for the favoured treatment, at that WTP) and save this as `max.nmb`. The average of all these maximum NMB values can be calculated using the `max()` function, and saved as `av.perfect`. This represents the average NMB across all simulations, if the correct was chosen every time. 

(v) Calculate the maximum NMB out of the two treatments under current knowledge, and call this (`max.current`). 

(vi) Finally, you can calculate the difference between the NMB from the preferred treatment across all simulations, versus the NMB if the best treatment was chosen across every simulation. This is the EVPI for each individual, and you can save this as `EVPI.indiv`. We've given some further hints in the template to help you through this, but remember that these results are all specific to the WTP defined above. 

(2) **Calculating the effective population**

Of course, there will be more than one patient eligible for a particular treatment.  Therefore, the individual patient EVPI must be inflated by the effective population, which is a function of the eligible patients per annum and the expected lifetime of the technology.  

*For the hip replacement example, we are going to assume an effective technology life of ten years with 40,000 new patients eligible for treatment each year. With a discount rate of 6% used in this case.*

(i) Using the above information, set the population, number of years and discount rate in the template script. 

(ii) We've then define a discounted population sequence for you, estimate the effective population by summing across this (i.e. summing across `population.seq`).

(iii) Estimate the population level EVPI by multiplying the effective population (`effective.population`) by the `EVPI.indiv` we calculated earlier on in the exercise.

(3)	**Calculating the population EVPI, using a function**

Since EVPI is calculated using net-benefit and net-benefit is a function of the unknown ceiling ratio it is important to estimate EVPI as a function of the ceiling ratio. We therefore need to wrap up what we've done in step 1 into a function, and run it across different WTP values.

(i) Define a new `WTP.values` vector running from 0 to 50,000 in increments of 100.

(ii) Based on what we've done so far, fill in the blanks left in the function `est.EVPI.pop()`. *(Hint: use the calculations in step 1 to help you)*

(iii) Create a data frame to capture the WTP values and subsequent population EVPI results (the latter can be set to NA first).

(iv) Fill in the rest of the for loop we've started to run the `est.EVPI.pop()` along different `WTP.values`.

Congratulations! You've completed your first EVPI in R. Take a look at the results you've got.

Now plot these results using the predefined ggplot functions given. 
Notice the peak in EVPI – where does this occur?

\newpage 

## PART 2: Step-by-step guide

(@) **Loading the appropriate model script and function**

The overall EVPI for the model is a useful upper limit on returns to future research.  However, of crucial importance is which particular parameters (or groups of related parameters) are most important in terms of having the greatest value of information.  Partial EVPI approaches are designed to look at just that.  They work by looking at the value of information of the remaining parameters of the model if we assume perfect information for the parameter of interest. 

Begin by loading up 'A4.3.3b_VoI_Model_Script' using the `source()` function. This is an adapted version of the model, which includes a function to run the Markov model - which we have labelled `model.THR.voi()`. Take a look at the script and the function. We have annoted the script to highlight changes that have been made in the script. You will notice that in this version of the model, rather than proabilistic parameters being included within the model function (i.e. sampling one value within each model simulation), these parameters are now sampled and stored before the model function is run. 

The main change here is that now instead of running the function and these parameters being automatically sampled, we instead have to pass the probabilistic parameter samples into the model function as an argument. The function will then use these parameters to generate the transition matrices and the Markov trace, and estimate the costs and QALYs for the two treatments. This is done in the same way as previous versions (except in some areas we have tried to speed up some of the code by avoiding loops). The reason we have done this is so that we can control which parameters are sampled, and when, by selecting the appropriate data in our inner and outer loops of the EVPPI. 

(@) **EVPPI Example walkthrough**

Before we perform the EVPPI analyses, we will show a walkthrough of the calculations, using the inner and outer loops and selecting the appropriate parameter values. Once you understand the calculations being performed, the next sections will set up the full EVPPI calculations, with additional complexity. Go to the 'EVPPI example walkthrough' section of the code to start this part of the exercise.

(i) First, create the `evppi.results.SP0.test` matrix. We will just use one willingness to pay threshold, so this matrix will only use one column for each treatment (note that in the full EVPPI analyses we will consider a range of WTP values). You can use this matrix to create a replicate, for the NP1 treatment. 

(ii) Next, create a matrix to store the results of the inner loop (i.e. the PSA for all other values after the partial parameter has been selected). 

(iii) Define a WTP value (the EVPPI is highest at £2,200, so that may be a good value to use)

(iv) Remember from the looking through the model script above, that we need to pass the appropriate parameters into the model function. Familiarise yourself with the input parameters sampled in the 'A4.3.3b_VoI_Model_Script' script that you ran earlier. We have provided these in the script for you, and have also given some code to show you how these parameters can be selected and given to the model. **It is very important that you understand how this data is being selected and passed to the model function for you to understand the rest of the exericse!** 

Next, we can start to look at how the EVPPI loop works. This task may seem repetitive, but the aim is to get a full appreciation of the approach before running the full code later, which will do the same thing but many more times, and across a range of willingness to pay values. 

We will use the letter 'a' to indicate the outer loop number, and the letter 'b' to indicate the inner loop number. We will use the relative risk parameter and evaluate the value of partial perfect information for this parameter (the sampled parameters are stored in the `RR.vec` vector). However, we are uncertain as to the true value of the relative risk, therefore the first step is to select a value from the samples of `RR.vec`.

(i) First, define 'a' as being equal to 1 (i.e. the first outer loop). Next, select the value of `RR.vec` using the outer loop as the indicator as to which value should be used. Use 'a' to select the first RR.vec value. You do not need to assign this yet, but be aware that it will go into the model function, within the inner loop. *(Note: the use of 'a' and 'b' in selecting the appropriate parameters is importnat to ensure the correct data are provided)*

(ii) Note that the value for the relative risk will be constant within the inner loop. Next, we can run 100 model simulations within the inner loop, and ensure that all other probabilistic parameters in the model are sampled. To do this, all other parameters inside the inner loop will be selected using 'b' so that they will change for each inner loop, whilst the relative risk value remains fixed (in each inner loop). To ensure that the relative risk remains fixed, whilst the other parameters are sampled inside the loop, the following code should be used to run the model. 

```{r model run, echo = TRUE}
model.THR.voi(RR.NP1 = RR.vec[a], lambda = lambda.vec[b], gamma = gamma.vec[b], 
   omr = omr[b,], c.revision = c.revision.vec[b], tp.rrr = tp.rrr.vec[b],
   state.util = state.utilities.df[b,])
```

You will see that each model simulation is then saved in the `inner.results` matrix. This shows the uncertainty in decision making whilst the relative risk parameter is known (i.e. perfect information). 

(iii) Next, calculate the mean NMB across the 100 simulations of the inner loop for both treatments (note that this uses the WTP value defined above). Then save these in the evppi.results matrix for both treatments. 

(iv) Now you need to repeat steps (i) to (iii), but selecting a new relative risk parameter in the outer loop. Change the value of 'a' to 2, and then rerun the code. 

(v) Do this 10 times, so that you have considered 10 samples of the parameter of interest for the EVPPI analysis (the relative risk parameter in this case)

(vi) Once you have done this, you should be able to view the NMB values for each outer loop. *(Hint: the NMB may be the same for the comparator across model runs, since the relative risk parameter selected does not influence the standard prosthesis)*

Next, you will calculate the value of information in the same way as we did for the EVPI in the previous section. 

(vii) Calculate the average NMB across the outer loops for both treatments. Whichever treatment has the maximum NMB is preferred, so take the maximum value (from the two treatments). 

(viii) For the perfect information (note that this is based on perfect information of the relative risk parameter only), take the maximum NMB of either treatment across each model simulation. This means that for every value of the relative risk parameter, the correct treatment, with the highest NMB, would be selected. Now take the mean value of these, to give the average NMB across the simulations (where the correct treatment is always selected). 

(ix) The EVPPI is the difference between these two values. You can subtract the current NMB from the NMB with perfect information for the parameter to calculate EVPPI. 

Note that in this walkthrough, the EVPPI is estimated per individual (since the model using a cohort size of 1).  Also, the results shown are only evaluating the EVPPI at one WTP value. Later on, you will see that we can evaluate the EVPPI across a range of WTP values. 


(@) **Loading the parameters and model functions**

Now we will walk through the code to perform EVPPI analyses for six sets of model parameters, and evaluate the EVPPI across a range of WTP thresholds. Before you start, there are parameters that need to be defined before you can complete the EVPPI analyses. Go to the 'EVPPI Model runs' section of the code to begin. 

(i) Define the number of inner and outer loops to run *(Note that the number here will need to be equal to or lower than the number of samples in the model script)*. You can set these to 100 each to allow the simulations to be run fairly quickly. 

However – and this is very important – accurate estimation of partial EVPIs takes many more runs than this – and we would recommend at least 1000 inner and 1000 outer loops. This is one of the advantages of using R, as doing this across each parameter in Excel would take a very long time (if it even manages to finish!). This is also one of the reasons that we should be aware of how we are coding our model in R, since a model with lots of loops and inefficient code will take a lot longer to run. Whilst this is less important when running a PSA or EVPI analysis, it will begin to have a big impact when using the nested loops used in EVPPI analyses. 

(ii) Now create a vector of lambda (i.e. WTP) values, so that we can evalauate the EVPPI across a range of thresholds. Also create the matrices to evaluate the inner loop results, and the overall evppi.results, to store results. You can see that the structure of the inner.results matrix remains the same as used in the walkthrough above. However, the evppi.results matrix is equal to the outer loop number, but also have a column for each lambda value being considered. In the next steps we will see how the results can be evaluated and stored here.   

(iii) Calculate the effective population that will benefit from the intervention over an appropriate time horizon. We have provided the information from part 1 of this exercise for you to run here. 

(iv) Next, run the code that provides the functions to estimate NMB for the inner loop results. This is essentially a function that estimates the mean NMB across all inner loop simulations (as you did in the initial part of this exercise after running the inner loops), except now it does this for a range of WTP values. The mean NMB values across all WTP thresholds are saved for each treatment. 

(v) Finally, run the code to create the `gen.evppi.results()` function. You can see from the function that this estimates the current and perfect information (as you did in the walkthrough of EVPPI results), except the function has been adapted to do this across all WTP values.  


(@) **Running the code for 100 inner and outer loops, for 6 parameter groups of interest**

Now that you understand the process behind calculating partial EVPIs, and have created the matrices and functions to save the results appropriately, take a moment to examine the EVPPI lopps coded for you, for each of the six groups of parameters. The code is similar in structure to the walkthrough you did earlier, albeit with more simulations, and with more WTP thresholds considered. Notice that for each EVPPI analysis, the parameter of interest will be selected in the outer loop (using 'a'), and the other parameters are included in the inner loop (sampled using 'b'). 

Looking at the model code below, you should be able to recognise which EVPPI analysis this code is from:
```{r, eval = FALSE}
model.THR.voi(RR.vec[b], lambda.vec[b], gamma.vec[b], omr[b,], 
              c.revision.vec[a], tp.rrr.vec[b], state.utilities.df[b,]) 
```

The above code is evaluating the EVPPI with perfect information with the cost of revision. What if you wanted to evaluate the value of partial information for two paramters that are arguments in the model function? You should be able to work out how to write the above code, but including two parameters in the outer loop, whilst all other remain in the inner loop.  

Once you've had a look at all the EVPPI loops and have understood them, run the code to perform them all. We have added a progress bar for you, for each of the six groups, so that you can see how long each EVPPI simulation takes. 

The speed to complete these analyses will depend on your computer (and what else your computer might be doing too), as well as the complexity of the model. In this example, each EVPPI analysis should be less than a minute. Needless to say, this where the efficiency of your code can start to make a meaninful difference to how long your simulations will take to run. 


(@) **Plotting and selecting the results of interest**

Now you have run and stored the results for the six different EVPPI analyses, we need to store them all in a data frame, and then to help us plot these in ggplot, reshape the data. 

Remember the results generated at this point are per patient, not for the population. 

(i) Create a data.frame combining all the results 

(ii) Multiply this data.frame by the effective population, to generate EVPPI results for the whole population

(iii) Now run the reshape function, to move the data from wide format to long format (so we can plot it in ggplot)

(iv) Next, it's time to visualise the results! Run the `plot.evppi()` function (remember this has been loaded in at the top of the script) to see the EVPPI results across the WTP thresholds, for the six sets of parameters. If you want to view the plot in more detail, click the 'zoom' button above the plot in the 'Plots' pane of R. The plot should look similar to this:

```{r evppi plot, echo = FALSE, warning=FALSE, message=FALSE, error=FALSE}
plot.evppi(evppi.long.pop)
```

(v) Finally, if you want to see the specific EVPPI results at any given WTP threshold value, you can use the `subset()` function to do this. We have provided some code to do this at £2,200 (where the EVPPI is high!)

```{r evppi subset, echo = TRUE}
subset(evppi.long.pop, lambda==2200)
```

\ 

**Congratulations!** You have now calculated the EVPPI for six sets of parameters in the model, and plotted them! Although we have done this using a relatively low number of inner and outer loops (100 each), you can always go back and run these at higher numbers to ensure that the results are robust (perhaps considering how long it took to run the 100 simulations each the first time!). 

